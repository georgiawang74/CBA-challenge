# -*- coding: utf-8 -*-
"""ARIMA/SARIMA.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BzXWuhZARD2PV4n2dwl0-dYRAePXTQp1
"""

#ARIMA and SARIMA

import warnings
warnings.filterwarnings("ignore")

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.stattools import adfuller

# ---------- Load & prep ----------
df = pd.read_csv("final_daily.csv")
df["Date"] = pd.to_datetime(df["Date"], utc=True, errors="coerce")
df = df.sort_values("Date").dropna(subset=["Date"]).reset_index(drop=True)

target_col = "Close"
ts = df[["Date", target_col]].dropna().set_index("Date").asfreq("D")
ts[target_col] = ts[target_col].ffill()

# Log-transform if strictly positive
use_log = (ts[target_col] > 0).all()
y = np.log(ts[target_col]) if use_log else ts[target_col]

# ADF-based differencing guess
def adf_test(series):
    series = series.dropna()
    res = adfuller(series, autolag="AIC")
    return {"adf_stat": res[0], "pvalue": res[1]}

adf_info = adf_test(y)
d_guess = 1 if adf_info["pvalue"] > 0.05 else 0

# ---------- Model candidates (tighter) ----------
p_values = [0,1,2]
q_values = [0,1,2]
d_values = [d_guess]
seasonal_ms = [7] if len(y) >= 200 else []  # weekly only if enough data

def fit_try(endog, order, seasonal_order=(0,0,0,0)):
    # Two-stage optimizer retry
    for method, maxiter in [("lbfgs", 2000), ("powell", 1000)]:
        try:
            model = SARIMAX(
                endog,
                order=order,
                seasonal_order=seasonal_order,
                enforce_stationarity=True,
                enforce_invertibility=True,
                concentrate_scale=True,
            )
            res = model.fit(method=method, maxiter=maxiter, disp=False)
            if np.isfinite(res.aic):
                return res, None
        except Exception as e:
            last_err = str(e)
            continue
    return None, last_err if 'last_err' in locals() else "Unknown fit error"

best = {"res": None, "cfg": None, "aic": np.inf, "err": None}

# Non-seasonal first
for p in p_values:
    for q in q_values:
        res, err = fit_try(y, (p, d_values[0], q))
        if res is not None and res.aic < best["aic"]:
            best = {"res": res, "cfg": {"order": (p,d_values[0],q), "seasonal_order": (0,0,0,0)}, "aic": res.aic, "err": None}

# Seasonal if applicable
for m in seasonal_ms:
    for p in [0,1]:
        for q in [0,1]:
            for P in [0,1]:
                for Q in [0,1]:
                    for D in [0,1]:
                        res, err = fit_try(y, (p, d_values[0], q), (P, D, Q, m))
                        if res is not None and res.aic < best["aic"]:
                            best = {"res": res, "cfg": {"order": (p,d_values[0],q), "seasonal_order": (P,D,Q,m)}, "aic": res.aic, "err": None}

# Fallback if nothing converged
if best["res"] is None:
    res, err = fit_try(y, (1,1,1))
    if res is None:
        raise RuntimeError(f"Model failed to converge even after fallbacks. Last error: {err}")
    else:
        best = {"res": res, "cfg": {"order": (1,1,1), "seasonal_order": (0,0,0,0)}, "aic": res.aic, "err": None}

best_res = best["res"]
best_cfg = best["cfg"]

# ---------- Forecast ----------
steps = 30
fc = best_res.get_forecast(steps=steps)
pred = fc.predicted_mean
conf = fc.conf_int(alpha=0.05)
conf.columns = ["lower", "upper"]

# If log-transform used, invert transform
if use_log:
    pred = np.exp(pred)
    conf = np.exp(conf)

# Assemble forecast frame with proper dates
last_date = ts.index.max()
future_index = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=steps, freq="D")
forecast_df = pd.DataFrame({"forecast": pred.values, "lower_95": conf["lower"].values, "upper_95": conf["upper"].values}, index=future_index)

# Save
out_path = "forecast_30d_convergence_safe.csv"
forecast_df.to_csv(out_path, index_label="Date")

# ---------- Plot ----------
plt.figure(figsize=(10,5))
hist_tail = ts[target_col].iloc[-400:] if len(ts) > 400 else ts[target_col]
hist_tail.plot(label="History")
forecast_df["forecast"].plot(label="Forecast")
plt.fill_between(forecast_df.index, forecast_df["lower_95"], forecast_df["upper_95"], alpha=0.2, label="95% CI")
plt.title(f"Best model (stabilized): order={best_cfg['order']}, seasonal_order={best_cfg['seasonal_order']}, AIC={best['aic']:.2f}")
plt.xlabel("Date")
plt.ylabel(target_col)
plt.legend()
plt.tight_layout()
plt.show()